# The Twelve Designs of Coding

		Any busy bird calls dates features intently memorizing oases simply (and)  
		singly (with) tickets.

1. Adapter — organize interactions between two objects with different interfaces #legacycode #thirdpartylibs #classist #defensive
2. Bridge — preserve an interface for vertically (rapid growth) or horizontally (multiple implementations) evolving code #featuremasking #classist #defensive
3. Builder — craft a multiply realizable rich object #encapsulation
4. Command — pass private references between first-class objects #sharedexecution
5. Decorator — divide and conquer data processing #gluecode #classist
6. Factory — dynamically generate objects #pleonastic #prefeaturing #classist
7. Interpeter — syntactical input management and translation #codeswitching #defensive
8. Memento — object change tracking and reversion capture #storedstates #predictivecoding #classist
9. Observer — objects who chat at objects #storedstates #classist
10. Singleton — classes with a static interface #encapsulation #modularity #classist
11. Strategy — objects who condition algorithms #encapsulation #defensive #singleresponsibility
12. Template Method — polymorphic algorithms by differing descriptions #familyresemblance #classist

## Other ideas

1. Favor object composition
2. Namespacing and tokenization, or hashblocking of event-driven channels and chains
3. Events flow up, state flows down.
4. Modularity should never move beyond 6 degrees (then-ables, hierarchies)
5. Self-documenting code, implementation details (prefer object composition, versioning over superficial variable names)
6. Properly hide brittle code from APIs with compositionality
